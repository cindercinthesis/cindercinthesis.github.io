---
import { v2 as cloudinary } from "cloudinary";
import { Picture } from "astro:assets";
import left from "../icons/chevron-left-solid.svg?raw";
import right from "../icons/chevron-right-solid.svg?raw";
import play from "../icons/circle-play-regular.svg?raw";
import loading from "../icons/loading.svg?raw";
import Icon from "../components/Icon.astro";

export interface Props {
  folder: string;
  filter?: string;
}

export interface CloudinaryResource {
  secure_url: string;
  resource_type: string;
  width: number;
  height: number;
  duration: number;
  aspect_ratio: number;
  context: { alt: string };
}

cloudinary.config({
  cloud_name: import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME,
  api_key: import.meta.env.PUBLIC_CLOUDINARY_API_KEY,
  api_secret: import.meta.env.SECRET_CLOUDINARY_API_KEY,
  secure: true,
});

const search = await cloudinary.search
  .expression(`folder:${Astro.props.folder}`)
  .with_field("context")
  .sort_by("display_name", "asc")
  .max_results(500)
  .execute();

const resources = search.resources as CloudinaryResource[];
const filteredResources = Astro.props.filter ? resources.filter((resource) => resource.resource_type == Astro.props.filter) : resources;
const tilePattern = ["full", "wide", "", "wide bottom", "", "", "full", ""];

---

<div class="gallery-grid">
  {
    filteredResources.map((CloudinaryResource, index) => {
      const baseClass = tilePattern[index % tilePattern.length];
      let staggerClass = "";

      // Stagger small tiles to create a staircase effect (no overlap)
      if (!baseClass) {
        const pair = Math.floor(index / 2);
        const positionInPair = index % 2; // 0 or 1
        const invert = pair % 2 === 1;
        const shouldBottom = invert ? positionInPair === 0 : positionInPair === 1;
        staggerClass = shouldBottom ? "bottom" : "";
      }

      const spanClass = `${baseClass} ${staggerClass}`.trim();
      const altText = CloudinaryResource.context?.alt || "";
      return (
        <div
          data-position={`${index == 0 ? "first" : index + 1 == filteredResources.length ? "last" : "middle"}`}
          onclick="setFullscreen(this)"
          ontouchend="if (!isScrolling) setFullscreen(this)"
          class={`gallery-item relative cursor-zoom-in fullscreen:cursor-auto ${spanClass}`}
          style={`aspect-ratio: ${CloudinaryResource.width} / ${CloudinaryResource.height};`}
          data-alt={altText}
        >
          <div role="status" class="absolute top-1/2 left-1/2 z-[2] hidden -translate-x-1/2 -translate-y-1/2 fullscreen:fixed fullscreen:block">
            <span class="sr-only">loading image...</span>
          </div>

          {CloudinaryResource.resource_type == "image" ? (
            <Picture
              src={CloudinaryResource.secure_url}
              width={CloudinaryResource.width}
              height={CloudinaryResource.height}
              widths={[800, 1200, 2000]}
              sizes="(min-width: 1150px) 50vw, (min-width: 900px) 75vw, 100vw"
              alt={CloudinaryResource.context?.alt || ""}
              class="resource absolute inset-0 h-full w-full object-contain opacity-0 transition-opacity duration-1000"
              loading={index <= 10 ? "eager" : "lazy"}
              onload="this.style.opacity=1; this.parentNode.querySelector('[role=status]').style.display = 'none';"
              draggable="false"
            />
          ) : (
            <div>
              <div>
                <video
                  id={`video-${index}`}
                  loop
                  webkit-playsinline
                  playsinline
                  muted
                  preload="none"
                  onclick="this.paused ? this.play() : this.pause()"
                  onmouseover="previewVideo(this)"
                  onmouseout="resetVideo(this)"
                  oncanplay="this.parentNode.previousElementSibling.style.display = 'none';"
                  class="resource pointer-events-none absolute top-0 h-full w-full object-contain align-bottom fullscreen:pointer-events-auto"
                >
                  <source src={CloudinaryResource.secure_url} type="video/mp4" />
                  Your browser does not support HTML video.
                </video>
              </div>

              <div class="video-duration pointer-events-none absolute bottom-0 flex w-full items-center justify-start bg-gradient-to-t from-black/50 to-transparent font-mono fullscreen:fixed fullscreen:left-0 fullscreen:z-[2] fullscreen:pl-6 fullscreen:pb-6">
                <Icon name="play" />
                <div class="text-xs">
                  <span id={`current-time-video-${index}`} class="current-time hidden fullscreen:inline-flex">
                    0:00 /{" "}
                  </span>
                  <span>{new Date(CloudinaryResource.duration * 1000).toISOString().slice(15, 19)}</span>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    })
  }
</div>

<div id="fullscreen-backdrop" class="scale-200 pointer-events-none fixed inset-0 z-[1] h-screen w-screen bg-black opacity-0 transition-opacity duration-200">
  <!-- but image -->
</div>

<div id="fullscreen-controls" class="pointer-events-none fixed top-0 z-[3] h-screen w-screen opacity-0 transition-opacity duration-200">
  <button type="button" onclick="prevResource()" class="fixed left-0 mt-[25vh] flex h-[50vh] w-[15vw] items-center opacity-0 hover:opacity-100 md:w-[25vw]">
    <div class="absolute left-0 ml-4 rounded-full bg-neutral-700 p-2 md:ml-8 md:p-4">
      <Icon name="left" />
      <span class="sr-only">previous image</span>
    </div>
  </button>

  <button type="button" onclick="nextResource()" class="fixed right-0 mt-[25vh] flex h-[50vh] w-[15vw] items-center opacity-0 hover:opacity-100 md:w-[25vw]">
    <div class="absolute right-0 mr-4 rounded-full bg-neutral-700 p-2 md:mr-8 md:p-4">
      <Icon name="right" />
      <span class="sr-only">next image</span>
    </div>
  </button>

  <button type="button" onclick="escapeFullscreen(true)" class="fixed ml-2 mt-2 rounded-full bg-neutral-700/50 p-3 hover:bg-neutral-700">
    <Icon name="x" />
    <span class="sr-only">exit image</span>
  </button>

  <div id="fullscreen-metadata" class="fixed right-0 top-0 h-screen w-96 bg-black/70 p-6 text-white">
    <h2 class="mb-2 text-xl font-bold" data-meta-title>Untitled</h2>
    <p class="text-sm text-gray-200 leading-relaxed" data-meta-body>Tap a photo to see details.</p>
  </div>
</div>

<script client:inline>
  let isAnimating = false;

  function setFullscreen(element, animation) {
    if (element.id == "fullscreen") {
      return;
    }

    disableScrolling();
    enableFullscreenControls();
    element.id = "fullscreen";

    const resource = element.querySelector(".resource");

    if (resource.readyState <= 1) resource.load();

    updateMetadata(fullscreen, resource);
    document.getElementById("fullscreen-metadata").style.opacity = "1";
    document.getElementById("fullscreen-metadata").style.pointerEvents = "auto";

    if (animation) {
      isAnimating = true;

      resource.classList.add(animation);
      fullscreenResource(resource);

      setTimeout(() => {
        playFullscreenVideo();
        resource.classList.remove(animation);
        isAnimating = false;
      }, 200);
    } else {
      zoomIn(resource);
    }
  }

  function escapeFullscreen(close) {
    const fullscreen = document.getElementById("fullscreen");

    if (!fullscreen || isAnimating) return;

    fullscreen.querySelector("video")?.pause();
    fullscreen.querySelector("video")?.blur();

    if (close) {
      zoomOut(fullscreen.querySelector(".resource"));
      disableFullscreenControls();
    } else {
      fullscreenResource(fullscreen.querySelector(".resource"));
    }
  }

  function zoomIn(resource) {
    resource.classList.add("zoom-in");
    fullscreenResource(resource);
    setTimeout(() => {
      resource.classList.remove("zoom-in");
    }, 200);
  }

  function zoomOut(resource) {
    if (!resource) return;
    resource.classList.add("zoom-out");
    setTimeout(() => {
      resource.classList.remove("zoom-out");
      const fullscreen = document.getElementById("fullscreen");
      if (fullscreen) fullscreen.removeAttribute("id");
    }, 200);
  }

  function fullscreenResource(resource) {
    const fullscreen = document.getElementById("fullscreen");
    const resourceHeight = resource.naturalHeight;
    const resourceWidth = resource.naturalWidth;

    fullscreen.classList.add("fullscreen");
    document.querySelector("#fullscreen-backdrop").classList.add("active");
    document.querySelector("#fullscreen-controls").classList.add("active");

    const changeBackdrop = () => {
      document.querySelector("#fullscreen-backdrop").classList.remove("active");
    };
    setTimeout(changeBackdrop, 200);

    // pre-position the next/previous resources by setting fullscreen transform properties
    resetResources();

    if (fullscreen.dataset.position == "first") {
      document.querySelectorAll(`[data-position="middle"]`).forEach((resource) => {
        resource.style.transform = `translateX(calc(100vw - ${resourceWidth / 2}px))`;
      });
      const last = document.querySelector(`[data-position="last"]`);
      last.style.transform = `translateX(calc(100vw - ${resourceWidth / 2}px))`;
    } else if (fullscreen.dataset.position == "last") {
      document.querySelectorAll(`[data-position="middle"]`).forEach((resource) => {
        resource.style.transform = `translateX(calc(-100vw + ${resourceWidth / 2}px))`;
      });
      const first = document.querySelector(`[data-position="first"]`);
      first.style.transform = `translateX(calc(-100vw + ${resourceWidth / 2}px))`;
    } else {
      const prev = fullscreen.previousElementSibling;
      prev.style.transform = `translateX(calc(-100vw + ${resourceWidth / 2}px))`;

      const next = fullscreen.nextElementSibling;
      next.style.transform = `translateX(calc(100vw - ${resourceWidth / 2}px))`;

      const first = document.querySelector(`[data-position="first"]`);
      first.style.transform = `translateX(calc(${100 * (1 - Array.from(fullscreen.parentNode.children).indexOf(fullscreen))}vw - ${
        resourceWidth / 2
      }px))`;

      const last = document.querySelector(`[data-position="last"]`);
      last.style.transform = `translateX(calc(-${100 * (Array.from(fullscreen.parentNode.children).length - 1 - Array.from(fullscreen.parentNode.children).indexOf(fullscreen))}vw - ${
        resourceWidth / 2
      }px))`;
    }

    // Center the clicked image or video in fullscreen
    resource.style.height = `${resourceHeight}px`;
    resource.style.width = `${resourceWidth}px`;
    resource.style.maxHeight = "60vh";
    resource.style.maxWidth = "90vw";

    // fix the fullscreen element when zoomed in fullscreen
    fullscreen.style.position = "fixed";
    fullscreen.style.top = "50%";
    fullscreen.style.left = "50%";
    fullscreen.style.transform = "translate(-50%, -50%)";
    fullscreen.style.width = `${resourceWidth}px`;
    fullscreen.style.height = `${resourceHeight}px`;
  }

  function enableFullscreenControls() {
    document.querySelector("#fullscreen-backdrop").classList.add("active");
    document.querySelector("#fullscreen-controls").classList.add("active");
  }

  function disableFullscreenControls() {
    const fullscreen = document.getElementById("fullscreen");
    if (fullscreen) fullscreen.removeAttribute("id");

    document.querySelector("#fullscreen-backdrop").classList.remove("active");
    document.querySelector("#fullscreen-controls").classList.remove("active");

    resetResources();
  }

  function updateMetadata(wrapper, resource) {
    const meta = document.getElementById("fullscreen-metadata");
    const titleEl = meta.querySelector("[data-meta-title]");
    const bodyEl = meta.querySelector("[data-meta-body]");

    const alt = wrapper.dataset.alt || "";
    const src = resource?.currentSrc || resource?.src || "";

    titleEl.textContent = alt || "Untitled";
    bodyEl.textContent = alt ? alt : src;
  }

  function resetResources() {
    const resources = document.querySelectorAll(".gallery .resource");
    resources.forEach((resource) => {
      resource.removeAttribute("style");
      resource.parentElement.removeAttribute("style");
    });
  }

  function prevResource() {
    const fullscreen = document.getElementById("fullscreen");
    if (fullscreen.previousElementSibling) {
      fullscreen.previousElementSibling.click();
    } else {
      // roll back to last image
      const last = document.querySelector(`[data-position="last"]`);
      last.click();
    }
  }

  function nextResource() {
    const fullscreen = document.getElementById("fullscreen");
    if (fullscreen.nextElementSibling) {
      fullscreen.nextElementSibling.click();
    } else {
      // roll to first image
      const first = document.querySelector(`[data-position="first"]`);
      first.click();
    }
  }

  let isScrolling = false;
  let timer;
  let lastTouchY = 0;

  function disableScrolling() {
    document.body.style.overflow = "hidden";
  }

  function enableScrolling() {
    document.body.style.overflow = "auto";
  }

  function previewVideo(video) {
    // avoid autoplay in fullscreen mode
    if (document.getElementById("fullscreen")) return;
    video.currentTime = 0;
    video.play();
  }

  function resetVideo(video) {
    if (document.getElementById("fullscreen")) return;
    video.pause();
    video.currentTime = 0;
  }

  document.addEventListener(
    "wheel",
    (event) => {
      clearTimeout(timer);
      isScrolling = true;
      timer = setTimeout(() => {
        isScrolling = false;
      }, 100);
    },
    false
  );

  document.addEventListener(
    "touchstart",
    (event) => {
      clearTimeout(timer);
      isScrolling = true;
      lastTouchY = event.touches[0].clientY;
    },
    false
  );

  document.addEventListener(
    "touchmove",
    (event) => {
      const currentTouchY = event.touches[0].clientY;
      const deltaY = Math.abs(currentTouchY - lastTouchY);
      if (deltaY > 5) {
        // consider any significant vertical movement as scrolling
        clearTimeout(timer);
        timer = setTimeout(() => {
          isScrolling = false;
        }, 100);
      }
    },
    false
  );

  document.addEventListener(
    "touchend",
    (event) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        isScrolling = false;
      }, 100);
    },
    false
  );
</script>

<style>
  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 12px;
    grid-auto-flow: dense;
  }

  .gallery-item {
    position: relative;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.02);
  }

  .gallery-item .resource {
    inset: 0;
  }

  .wide {
    grid-column: span 2;
  }

  .bottom {
    align-self: end;
  }

  .full {
    grid-column: 1 / -1;
  }

  @media (max-width: 640px) {
    .gallery-grid {
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 8px;
    }
  }
</style>
