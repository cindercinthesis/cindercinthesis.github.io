---
import { v2 as cloudinary } from "cloudinary";
import { Picture } from "astro:assets";
import left from "../icons/chevron-left-solid.svg?raw";
import right from "../icons/chevron-right-solid.svg?raw";
import play from "../icons/circle-play-regular.svg?raw";
import loading from "../icons/loading.svg?raw";
import Icon from "../components/Icon.astro";

export interface Props {
  folder: string;
  filter?: string;
}

export interface CloudinaryCustomContext {
  title?: string;
  name?: string;
  time?: string;
  date?: string;
  location?: string;
  place?: string;
  description?: string;
  body?: string;
  caption?: string;
  [key: string]: string | undefined;
}

export interface CloudinaryContext {
  alt?: string;
  caption?: string;
  custom?: CloudinaryCustomContext;
}

export interface CloudinaryResource {
  secure_url: string;
  resource_type: string;
  width: number;
  height: number;
  duration: number;
  aspect_ratio: number;
  context?: CloudinaryContext;
}

cloudinary.config({
  cloud_name: import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME,
  api_key: import.meta.env.PUBLIC_CLOUDINARY_API_KEY,
  api_secret: import.meta.env.SECRET_CLOUDINARY_API_KEY,
  secure: true,
});

const search = await cloudinary.search
  .expression(`folder:${Astro.props.folder}`)
  .with_field("context")
  .sort_by("display_name", "asc")
  .max_results(500)
  .execute();

const resources = search.resources as CloudinaryResource[];
const filteredResources = Astro.props.filter ? resources.filter((resource) => resource.resource_type == Astro.props.filter) : resources;
const tilePattern = ["full", "wide", "", "wide bottom", "", "", "full", ""];

---

<div class="gallery-grid">
  {
    filteredResources.map((CloudinaryResource, index) => {
      const baseClass = tilePattern[index % tilePattern.length];
      let staggerClass = "";

      // Stagger small tiles to create a staircase effect (no overlap)
      if (!baseClass) {
        const pair = Math.floor(index / 2);
        const positionInPair = index % 2; // 0 or 1
        const invert = pair % 2 === 1;
        const shouldBottom = invert ? positionInPair === 0 : positionInPair === 1;
        staggerClass = shouldBottom ? "bottom" : "";
      }

      const spanClass = `${baseClass} ${staggerClass}`.trim();
      const altText = CloudinaryResource.context?.alt || "";
      const customContext: CloudinaryCustomContext = CloudinaryResource.context?.custom ?? {};
      const metaTitle = customContext.title || customContext.name || CloudinaryResource.context?.caption || "";
      const metaTime = customContext.time || customContext.date || "";
      const metaLocation = customContext.location || customContext.place || "";
      const metaBody = customContext.description || customContext.body || CloudinaryResource.context?.alt || "";
      return (
        <div
          data-position={`${index == 0 ? "first" : index + 1 == filteredResources.length ? "last" : "middle"}`}
          onclick="setFullscreen(this)"
          ontouchend="if (!isScrolling) setFullscreen(this)"
          class={`gallery-item relative cursor-pointer fullscreen:cursor-auto ${spanClass}`}
          style={`aspect-ratio: ${CloudinaryResource.width} / ${CloudinaryResource.height};`}
          data-alt={altText}
          data-meta-title={metaTitle}
          data-meta-time={metaTime}
          data-meta-location={metaLocation}
          data-meta-body={metaBody}
        >
          <div role="status" class="absolute top-1/2 left-1/2 z-[2] hidden -translate-x-1/2 -translate-y-1/2 fullscreen:fixed fullscreen:block">
            <span class="sr-only">loading image...</span>
          </div>

          {CloudinaryResource.resource_type == "image" ? (
            <Picture
              src={CloudinaryResource.secure_url}
              width={CloudinaryResource.width}
              height={CloudinaryResource.height}
              widths={[800, 1200, 2000]}
              sizes="(min-width: 900px) 70vw, 100vw"
              alt={CloudinaryResource.context?.alt || ""}
              class="resource absolute inset-0 h-full w-full object-contain opacity-0 transition-opacity duration-1000"
              loading={index <= 10 ? "eager" : "lazy"}
              onload="this.style.opacity=1; this.parentNode.querySelector('[role=status]').style.display = 'none';"
              draggable="false"
            />
          ) : (
            <div>
              <div>
                <video
                  id={`video-${index}`}
                  loop
                  webkit-playsinline
                  playsinline
                  muted
                  preload="none"
                  onclick="this.paused ? this.play() : this.pause()"
                  onmouseover="previewVideo(this)"
                  onmouseout="resetVideo(this)"
                  oncanplay="this.parentNode.previousElementSibling.style.display = 'none';"
                  class="resource pointer-events-none absolute top-0 h-full w-full object-contain align-bottom fullscreen:pointer-events-auto"
                >
                  <source src={CloudinaryResource.secure_url} type="video/mp4" />
                  Your browser does not support HTML video.
                </video>
              </div>

              <div class="video-duration pointer-events-none absolute bottom-0 flex w-full items-center justify-start bg-gradient-to-t from-black/50 to-transparent font-mono fullscreen:fixed fullscreen:left-0 fullscreen:z-[2] fullscreen:pl-6 fullscreen:pb-6">
                <Icon name="play" />
                <div class="text-xs">
                  <span id={`current-time-video-${index}`} class="current-time hidden fullscreen:inline-flex">
                    0:00 /{" "}
                  </span>
                  <span>{new Date(CloudinaryResource.duration * 1000).toISOString().slice(15, 19)}</span>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    })
  }
</div>

<div id="fullscreen-backdrop" class="scale-200 pointer-events-none fixed inset-0 z-[1] h-screen w-screen bg-black opacity-0 transition-opacity duration-200">
  <!-- but image -->
</div>

<div id="fullscreen-controls" class="fixed top-0 z-[3] h-screen w-screen transition-opacity duration-200">
  <button
    type="button"
    onclick="prevResource()"
    class="fullscreen-prev fixed left-0 mt-[25vh] flex h-[50vh] w-[15vw] items-center justify-start opacity-0 hover:opacity-100 md:w-[25vw]"
  >
    <span class="fullscreen-control fullscreen-control-arrow ml-4 md:ml-8" aria-hidden="true">
      <span class="fullscreen-control-glyph">&#8592;</span>
    </span>
    <span class="sr-only">previous image</span>
  </button>

  <button
    type="button"
    onclick="nextResource()"
    class="fullscreen-next fixed right-0 mt-[25vh] flex h-[50vh] w-[15vw] items-center justify-end opacity-0 hover:opacity-100 md:w-[25vw]"
  >
    <span class="fullscreen-control fullscreen-control-arrow mr-4 md:mr-8" aria-hidden="true">
      <span class="fullscreen-control-glyph">&#8594;</span>
    </span>
    <span class="sr-only">next image</span>
  </button>

  <button type="button" onclick="escapeFullscreen(true)" class="fullscreen-close fullscreen-control" aria-label="cancel preview">
    <span class="fullscreen-control-glyph" aria-hidden="true">&#10007;</span>
    <span class="sr-only">cancel preview</span>
  </button>

  <div id="fullscreen-metadata" class="fullscreen-metadata">
    <div class="meta-inner">
      <h2 class="meta-title" data-meta-title></h2>
      <p class="meta-line" data-meta-line></p>
      <p class="meta-body" data-meta-body></p>
    </div>
  </div>
</div>

<script client:inline>
  let isAnimating = false;

  function setFullscreen(element, animation) {
    if (element.id == "fullscreen") {
      return;
    }

    const currentFullscreen = document.getElementById("fullscreen");
    if (currentFullscreen) {
      currentFullscreen.removeAttribute("id");
      currentFullscreen.classList.remove("fullscreen");
    }

    disableScrolling();
    enableFullscreenControls();
    element.id = "fullscreen";

    const resource = element.querySelector(".resource");

    if (resource.readyState <= 1) resource.load();

    updateMetadata(element);

    if (animation) {
      isAnimating = true;

      resource.classList.add(animation);
      fullscreenResource(resource);

      setTimeout(() => {
        playFullscreenVideo();
        resource.classList.remove(animation);
        isAnimating = false;
      }, 200);
    } else {
      zoomIn(resource);
    }
  }

  function escapeFullscreen(close) {
    const fullscreen = document.getElementById("fullscreen");

    if (!fullscreen || isAnimating) return;

    fullscreen.querySelector("video")?.pause();
    fullscreen.querySelector("video")?.blur();

    if (close) {
      zoomOut(fullscreen.querySelector(".resource"));
      disableFullscreenControls();
    } else {
      fullscreenResource(fullscreen.querySelector(".resource"));
    }
  }

  function zoomIn(resource) {
    resource.classList.add("zoom-in");
    fullscreenResource(resource);
    setTimeout(() => {
      resource.classList.remove("zoom-in");
    }, 200);
  }

  function zoomOut(resource) {
    if (!resource) return;
    resource.classList.add("zoom-out");
    setTimeout(() => {
      resource.classList.remove("zoom-out");
      const fullscreen = document.getElementById("fullscreen");
      if (fullscreen) {
        fullscreen.removeAttribute("id");
        fullscreen.classList.remove("fullscreen");
      }
    }, 200);
  }

  function fullscreenResource(resource) {
    const fullscreen = document.getElementById("fullscreen");
    const isStacked = window.matchMedia("(max-width: 900px)").matches;
    const shiftOffset = Math.round(window.innerWidth * (isStacked ? 0.5 : 0.35));

    document.querySelector("#fullscreen-backdrop").classList.add("active");
    document.querySelector("#fullscreen-controls").classList.add("active");

    // pre-position the next/previous resources by setting fullscreen transform properties
    resetResources();

    if (fullscreen.dataset.position == "first") {
      document.querySelectorAll(`[data-position="middle"]`).forEach((resource) => {
        resource.style.transform = `translateX(calc(100vw - ${shiftOffset}px))`;
      });
      const last = document.querySelector(`[data-position="last"]`);
      last.style.transform = `translateX(calc(100vw - ${shiftOffset}px))`;
    } else if (fullscreen.dataset.position == "last") {
      document.querySelectorAll(`[data-position="middle"]`).forEach((resource) => {
        resource.style.transform = `translateX(calc(-100vw + ${shiftOffset}px))`;
      });
      const first = document.querySelector(`[data-position="first"]`);
      first.style.transform = `translateX(calc(-100vw + ${shiftOffset}px))`;
    } else {
      const prev = fullscreen.previousElementSibling;
      prev.style.transform = `translateX(calc(-100vw + ${shiftOffset}px))`;

      const next = fullscreen.nextElementSibling;
      next.style.transform = `translateX(calc(100vw - ${shiftOffset}px))`;

      const first = document.querySelector(`[data-position="first"]`);
      first.style.transform = `translateX(calc(${100 * (1 - Array.from(fullscreen.parentNode.children).indexOf(fullscreen))}vw - ${shiftOffset}px))`;

      const last = document.querySelector(`[data-position="last"]`);
      last.style.transform = `translateX(calc(-${100 * (Array.from(fullscreen.parentNode.children).length - 1 - Array.from(fullscreen.parentNode.children).indexOf(fullscreen))}vw - ${shiftOffset}px))`;
    }
  }

  function enableFullscreenControls() {
    document.querySelector("#fullscreen-backdrop").classList.add("active");
    document.querySelector("#fullscreen-controls").classList.add("active");
  }

  function disableFullscreenControls() {
    const fullscreen = document.getElementById("fullscreen");
    if (fullscreen) fullscreen.removeAttribute("id");

    document.querySelector("#fullscreen-backdrop").classList.remove("active");
    document.querySelector("#fullscreen-controls").classList.remove("active");

    resetResources();
    enableScrolling();
  }

  function updateMetadata(wrapper) {
    const meta = document.getElementById("fullscreen-metadata");
    const titleEl = meta.querySelector("[data-meta-title]");
    const lineEl = meta.querySelector("[data-meta-line]");
    const bodyEl = meta.querySelector("[data-meta-body]");

    const title = (wrapper.dataset.metaTitle || "").trim();
    const time = (wrapper.dataset.metaTime || "").trim();
    const location = (wrapper.dataset.metaLocation || "").trim();
    const body = (wrapper.dataset.metaBody || "").trim();
    const lineText = [time, location].filter(Boolean).join(" | ");

    setMetaText(titleEl, title);
    setMetaText(lineEl, lineText);
    setMetaText(bodyEl, body);
  }

  function setMetaText(element, value) {
    if (!element) return;
    if (value) {
      element.textContent = value;
      element.style.display = "";
    } else {
      element.textContent = "";
      element.style.display = "none";
    }
  }

  function resetResources() {
    const items = document.querySelectorAll(".gallery-grid .gallery-item");
    items.forEach((item) => {
      item.style.removeProperty("transform");
    });

    const resources = document.querySelectorAll(".gallery-grid .resource");
    resources.forEach((resource) => {
      resource.style.removeProperty("height");
      resource.style.removeProperty("width");
      resource.style.removeProperty("max-height");
      resource.style.removeProperty("max-width");
    });
  }

  function prevResource() {
    const items = Array.from(document.querySelectorAll(".gallery-grid .gallery-item"));
    const fullscreen = document.getElementById("fullscreen");
    if (!fullscreen || items.length === 0) return;

    const currentIndex = items.indexOf(fullscreen);
    if (currentIndex === -1) return;
    const nextIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
    setFullscreen(items[nextIndex]);
  }

  function nextResource() {
    const items = Array.from(document.querySelectorAll(".gallery-grid .gallery-item"));
    const fullscreen = document.getElementById("fullscreen");
    if (!fullscreen || items.length === 0) return;

    const currentIndex = items.indexOf(fullscreen);
    if (currentIndex === -1) return;
    const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
    setFullscreen(items[nextIndex]);
  }

  let isScrolling = false;
  let timer;
  let lastTouchY = 0;

  function disableScrolling() {
    document.body.style.overflow = "hidden";
  }

  function enableScrolling() {
    document.body.style.overflow = "auto";
  }

  function previewVideo(video) {
    // avoid autoplay in fullscreen mode
    if (document.getElementById("fullscreen")) return;
    video.currentTime = 0;
    video.play();
  }

  function resetVideo(video) {
    if (document.getElementById("fullscreen")) return;
    video.pause();
    video.currentTime = 0;
  }

  document.addEventListener(
    "wheel",
    (event) => {
      clearTimeout(timer);
      isScrolling = true;
      timer = setTimeout(() => {
        isScrolling = false;
      }, 100);
    },
    false
  );

  document.addEventListener(
    "touchstart",
    (event) => {
      clearTimeout(timer);
      isScrolling = true;
      lastTouchY = event.touches[0].clientY;
    },
    false
  );

  document.addEventListener(
    "touchmove",
    (event) => {
      const currentTouchY = event.touches[0].clientY;
      const deltaY = Math.abs(currentTouchY - lastTouchY);
      if (deltaY > 5) {
        // consider any significant vertical movement as scrolling
        clearTimeout(timer);
        timer = setTimeout(() => {
          isScrolling = false;
        }, 100);
      }
    },
    false
  );

  document.addEventListener(
    "touchend",
    (event) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        isScrolling = false;
      }, 100);
    },
    false
  );
</script>

<style>
  .gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 12px;
    grid-auto-flow: dense;
  }

  .gallery-item {
    position: relative;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.02);
  }

  .gallery-item .resource {
    inset: 0;
  }

  .wide {
    grid-column: span 2;
  }

  .bottom {
    align-self: end;
  }

  .full {
    grid-column: 1 / -1;
  }

  #fullscreen-controls {
    opacity: 0;
    pointer-events: none;
  }

  #fullscreen-controls.active {
    opacity: 1;
    pointer-events: auto;
  }

  #fullscreen-backdrop.active {
    opacity: 0.85;
  }

  #fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 70vw;
    height: 100vh;
    padding: 4vh 4vw;
    display: flex;
    align-items: center;
    justify-content: center;
    transform: none;
    z-index: 2;
  }

  #fullscreen .resource {
    position: relative;
    inset: auto;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
  }

  #fullscreen-controls .fullscreen-next {
    right: 30vw;
  }

  .fullscreen-prev,
  .fullscreen-next {
    z-index: 4;
  }

  .fullscreen-control {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: clamp(2.6rem, 6vw, 3.6rem);
    height: clamp(2.6rem, 6vw, 3.6rem);
    border: 2px solid rgba(242, 231, 215, 0.55);
    border-radius: 999px;
    background: rgba(12, 12, 16, 0.55);
    color: #f5efe5;
    padding: 0;
    font-family: "Cormorant Garamond", "Iowan Old Style", Georgia, serif;
    font-size: clamp(1.6rem, 3.2vw, 2.4rem);
    line-height: 1;
    font-style: italic;
    letter-spacing: 0.04em;
    text-decoration: none;
    transition: transform 150ms ease, background 150ms ease, border-color 150ms ease;
  }

  .fullscreen-control::after {
    content: "";
    position: absolute;
    inset: -4px;
    border: 1px solid rgba(242, 231, 215, 0.35);
    border-radius: 999px;
    transform: rotate(-5deg);
    pointer-events: none;
  }

  .fullscreen-control:hover,
  .fullscreen-control:focus-visible {
    background: rgba(18, 18, 24, 0.85);
    border-color: rgba(255, 255, 255, 0.7);
    transform: rotate(1deg);
  }

  .fullscreen-control-glyph {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    line-height: 1;
    text-align: center;
    font-style: normal;
    letter-spacing: 0;
  }

  .fullscreen-control-arrow {
    font-size: clamp(1.8rem, 3.8vw, 2.8rem);
  }

  .fullscreen-control-arrow .fullscreen-control-glyph {
    transform: translateY(-2px);
  }

  .fullscreen-close {
    position: fixed;
    top: 3.5vh;
    left: 4vw;
    z-index: 4;
    appearance: none;
    cursor: pointer;
  }

  .fullscreen-metadata {
    position: fixed;
    right: 0;
    top: 0;
    z-index: 3;
    height: 100vh;
    width: 30vw;
    min-width: 240px;
    padding: 3rem 2.5rem;
    background: rgba(8, 8, 12, 0.85);
    color: #f5efe5;
    border-left: 1px solid rgba(242, 231, 215, 0.18);
    overflow-y: auto;
  }

  .fullscreen-metadata .meta-title {
    margin: 0 0 0.6rem;
    font-size: clamp(1.4rem, 2.4vw, 2.3rem);
    font-weight: 600;
    font-family: "Cormorant Garamond", "Iowan Old Style", Georgia, serif;
  }

  .fullscreen-metadata .meta-line {
    margin: 0;
    font-size: 0.85rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: #e6d6b9;
    font-family: "Neue Haas Grotesk", "Helvetica Neue", Arial, sans-serif;
  }

  .fullscreen-metadata .meta-body {
    margin: 1rem 0 0;
    font-size: 1rem;
    line-height: 1.7;
    color: #f0e7d8;
    font-family: "Neue Haas Grotesk", "Helvetica Neue", Arial, sans-serif;
    white-space: pre-line;
  }

  @media (max-width: 640px) {
    .gallery-grid {
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 8px;
    }
  }

  @media (max-width: 900px) {
    #fullscreen {
      width: 100vw;
      height: 65vh;
      padding: 2.5vh 6vw;
    }

    #fullscreen-controls .fullscreen-next {
      right: 0;
    }

    .fullscreen-close {
      top: 2.5vh;
      left: 6vw;
    }

    .fullscreen-metadata {
      top: auto;
      bottom: 0;
      width: 100vw;
      height: 35vh;
      max-width: none;
      min-width: 0;
      border-left: none;
      border-top: 1px solid rgba(242, 231, 215, 0.18);
    }
  }
</style>
